title: Redux Primer
headline: A basic, barebones tutorial for Redux
author: Devin Eldreth
date: 19-02-2017

{% extends "post.html" %}
{% block body %}
{{ READ_TIME }}

{% filter markdown:"fenced-code-blocks" %}
{% verbatim %}
<a name='toc'></a>
# Table of Contents
1. [History: Flux and Redux](#history)
2. [Terms](#terms)
2. [The Three Principles](#three)
3. [Data Flow](#data-flow)
4. [Action Types and Creators](#actions)
5. [The Store](#store)
6. [Middleware](#middleware)
7. [Immutability](#immutability)
8. [Reducers](#reducers)
9. [Side Effects](#side-effects)
10. [Application Structure](#structure)

_Some examples in this article use Flow typing._

---

I've been working with React and subsequently Redux for nearly two years. On
occassion I still hear people expressing confusion over Redux. The goal of
this tutorial is to provide a basic but comprehensive series of explainations
for all things Redux. Several of the sections will also provide coding tasks
and examples that can be worked on independently.

Redux isn't out to get you. Sit back. Deep breath. Here we go.

# History: Flux and Redux <a name="history"></a>
To get where you're going it's important to know where you've been. Enter
Flux. React at a very high level has always been a library for writing user
interfaces. It never provided any strong data separation. Each component had
state and various things modified that state. Communication between components
largely boiled down to passing props down to children. Flux provides a
unidirectional data flow: actions sent through a dispatcher which routed to
a store and a change event would eventually be fired so components could
rerender. Flux showed that React applications could have a separation of
concerns. The store could reduce state and the view layer needed only rerender
from the current state.

**The basis of this data flow remain in Redux.**

Redux took the ideas behind Flux and wrapped them up in a more consumable way.
It removed the need to architect a system of a concept specific to React and
allowed developers to focus on maintaining state.

If you want to know more about the history and motivation behind redux then I
suggest checking out the [Prior Art](http://redux.js.org/docs/introduction/PriorArt.html)
of the Redux docs.

<!-- ### The Confusion of Flux
So often we find ourselves simply installing a new package to gain a new
piece of functionality that solves a problem. Flux wasn't something we could
just plug into an already running application. Using it required that the
application be architected around its concepts. I think this created a lot of
initial confusion surrounding flux.  -->

[top](#toc)

---
<a name="terms"></a>
# Terms

**Action**: Strings that represent the name of an action. Usually defined as a
constant. I refer to these as types.
```javascript
const HAS_APPLES = 'HAS_APPLES';
```

**Action Creator**: Functions that return an object that describes an action.
I often refer to these as actions. Think of them as giving context to an
action that by itself has little meaning.
```javascript
const hasApples = ( number_of_apples ) => {
  return {
    type: HAS_APPLES,
    number_of_apples
  };
};
```

**Reducer**: Pure functions that accept two arugments: the previous state and
the return of an action creator (I will usually just refer to this as the
action). Reducers return the next or new state. They **DO NOT** modify the
state that they were given.
```javascript
const hasApplesReducer = ( state = PREVIOUS_STATE, action ) => {
  return {
    ...state,
    apples: action.number_of_apples
  };
};
```

**Store**: All things Redux pass through the store. It is an object that
provides the following:

1. Stores application state.
2. Allows access to state through `getState()`.
3. Allows state to be updated with `dispatch(action)`.
4. Registers listeners via `subscribe(listener)`.
6. Handles unregistering of listeners via the function returned by
   `subscribe(listener)`.

[top](#toc)

---
<a name="three"></a>
# The Three Principles

### 1. Single Source of Truth
This principle is actually quite simple: The entire state of your application
should be represented as a single object within a single store.

### 2. State is Immutable
Also conceptually straight forward. **State cannot be modified directly.**
The only way to modify state is by dispatching actions that describe the
changes that should happen to state.

### 3. State Updates are Made with Pure Functions
Pure functions. For a function to be pure the following statements must hold:

1. The function always evaluates the same result given the same arguments. The
  result cannot depend on any hidden information that could change during
  execution.
2. Evaluation of the result does not cause any side effects.

This means that our **reducers** will always be pure functions. They take
a previous state and an action and return the next or new state.

[top](#toc)

---
<a name="data-flow"></a>
# Data Flow

Data flow in Redux is unidirectional. The attached diagram shows the flow of
data relative to a 'View' or some 'Side Effect'. All actions pass through the
store and the store provides state. Take
note that unlike Flux redux does not use the concept of a Dispatcher, but the
store does provide a dispatch function. This diagram abstracts this out as the
entry point of the store.

Redux allows for functions to be executed as middleware to extend the
functionality of the store. Remember principle 3: **state updates are made
with pure functions**. Middlwares give added functionality to actions moving
through the store. Middlewares also commonly create **side effects** named
because they are a side effect of the action that was dispatched. A middleware
could also just be a call to `console.log` to allow us inspection of the
action.

The **View** in this diagram is an abstract concept of the view layer. Since
we will be talking about Redux and its relationship to React the **View**
could be a `connect()` wrapped component and includes the expectation that
the **View** will be rendering and potentially dispatching its own actions.

_The same abstraction applies to **Side Effects**._

<a
    target='_blank'
    href='http://i.imgur.com/5miA6AT.png'>
    <img src='http://i.imgur.com/5miA6AT.png' style='width:100%;'>
</a>

[top](#toc)

---
<a name="actions"></a>
# Action Types and Creators
I mentioned before that I prefer to refer to actions as types and action
creators simply as creators. This helps avoid some confusion over the
expectations of an action and an action creator.

### Types
Types are very straight forward. They're a value, usually a string, defined as
a constant. They're analogous to a event name. In organizing my react redux
applications I tend to prefer prefixing types with some label that indicates
their relationship with the rest of redux: `APP_`, `TRACK_`, etc.

These are valid types:
```javascript
const APP_START = 'APP_START';
const AUTH_SUCCESS = 'AUTH_SUCCESS';
```

### Creators
Action creators are functions that return an object that describes an action
type. By themselves types are not very discriptive and in order to use them
with Redux's dispatch they need to be part of an object. Creators let us
handle that expectation.

types.js
```javascript
export const AUTH_SUCCESS = 'AUTH_SUCCESS';
```

We now have a type called `AUTH_SUCCESS` but we don't know what it actually does.

creators.js
```javascript
import { AUTH_SUCCESS } from './types';

export const authSuccess = ( user: Object ) => ({
  type: AUTH_SUCCESS,
  user
});
```

From the `authSuccess( user )` creator we can tell that dispatches of action
`AUTH_SUCCESS` will expect a user object.

Action creators need not be any more complicated than this. They're simply
functions that describe the types they use. They only need to return an object
that has a **type** property.


[top](#toc)

---
<a name="store"></a>
# The Store
The Redux Store is the workhorse of redux. Everything that is Redux passes
through the store. In turn the store exposes the state and dispatch of Redux.
Stores can get pretty complicated as they're extended through middleware.
Often store creation is wrapped within a function. I will show both examples

This is the most basic of stores:
```javascript
import { createStore } from 'redux';
import reducer from '../reducers/';

export default createStore( reducer );
```

Here we've done nothing really exciting with our store. We provided redux's
`createStore()` with our reducer and exported the resulting store. Stores
don't need to by any more complicated than this. However, in setup for the
next section I'll show what a more robust store might look like.

```javascript
import { createStore, applyMiddleware, compose } from 'redux';
import reducer from '../reducers/';

export default (): Object => {
  const middleware = [];

  const enhancers = compose(
    applyMiddleware( ...middleware )
  );

  return createStore(
    reducer,
    enhancers
  );
};
```
We've now created a store with the expectation that it will have middleware
that **enhance** its functionality through compose. Compose is a useful
functional utility that takes a variable number of arguments that are
functions and like the [docs](http://redux.js.org/docs/api/compose.html)
say: **don't overthink it**.

Also, I prefer returning my store as a function. This isn't a requirement. You
also export an [IIFE](https://en.wikipedia.org/wiki/Immediately-invoked_function_expression)
or the created object itself.


[top](#toc)

---
<a name="middleware"></a>
# Middleware
Our store is ready to party. Though, say we want to log actions as they move
through the store. The best way to do this is through the store's middleware.
Remember that state is immutable. Middleware must respect this princple.
However, they can expose all sorts of functionality to the store. Logging
is fairly straight forward and if you've got any experience with Express'
middleware api then this should sit well with you.

The basic structure of a middleware:
```javascript
const middleware = store => next => action => {
  return next( action );
};
```

[top](#toc)

---
<a name="immutability"></a>
# Immutability


[top](#toc)

---
<a name="reducers"></a>
# Reducers


[top](#toc)

---
<a name="side-effects"></a>
# Side Effects


[top](#toc)

{% endverbatim %}
{% endfilter %}
{% endblock body %}
